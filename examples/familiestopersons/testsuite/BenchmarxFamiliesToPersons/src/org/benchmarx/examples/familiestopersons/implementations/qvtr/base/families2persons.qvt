transformation families2persons (famDB : Families, perDB : Persons, conf: transconf2) {

	-- Bidirectional transformation between family and person databases
	--
	-- The transformation works as expected in forward direction.
	-- With the trace-based semantics of medini QVT, a bijective mapping
	-- is created between member and person objects. With check-before-
	-- enforce, the mapping would be n:1 in the case
	-- the database contains duplicate objects, i.e., objects with
    -- duplicate names. 
    --
    -- In backward direction, each male is transformed into a father,
    -- and each female is transformed into a mother, respectively.
    -- Each person gets its own family. This is just one of many
    -- conceivable default transformations.
    --
    -- To achieve the behavior of the backward transformation, the relations
    -- 'Son2Male' and 'Daughter2Female' must be disabled in backward direction.
    -- This is realized by a workaround: The transformation direction is stored
    -- in a small configuration model (consisting of a single object with a
    -- boolean attribute) such that it can be queried during transformation
    -- execution.  
    --
    -- Unfortunately, the transformation still does not behave as required
    -- in checkonly mode in backward direction. Here, each person should
    -- be represented exactly once as a family member with the same gender
    -- (e.g., either as a father or as a son). However, the rules insist
    -- on representing males as fathers and females as mothers, respectively
    -- (no sons or daughters). This is too restrictive.
    --
    -- Summarizing:
    --
    -- As far as execution in medini QVT is concerned, the transformation executes
    -- correctly in both directions (in enforcing mode; medini QVT does not
    -- support checkonly transformations).
    --
    -- As far as the behavior according to the standard is concerned, there are
    -- still two flaws:
    -- 1. The checkonly backward transformation is too demanding (see above).
    -- 2. Due to the check-before-enforce semantics, a bijective mapping 
    --    between member and person objects cannot be guaranteed.

	top relation FamilyRegister2PersonRegister {
		forward: Boolean;
	
		enforce domain famDB familyRegister : Families::FamilyRegister {};
		
		checkonly domain conf direction : transconf2::Direction {
			forward = forward
		};
		
		enforce domain perDB personRegister : Persons::PersonRegister {};
		
		where {
			Father2Male(familyRegister, personRegister);
			if forward then Son2Male(familyRegister, personRegister) else true endif;
			Mother2Female(familyRegister, personRegister);
			if forward then Daughter2Female(familyRegister, personRegister) else true endif;
		}
	}
	
	-- For indexOf: Actual value = expected value - 1 
	
	query familyName(name : String) : String {
		name.substring(1, name.indexOf(','))
	}
	
	query firstName(name : String) : String {
		name.substring(name.indexOf(',') + 3, name.size())
	}

	
	relation Father2Male {
		familyName, firstName, fullName : String;
	
		enforce domain famDB familyRegister : Families::FamilyRegister {
			families = family : Families::Family {
				name = familyName,
				father = father : Families::FamilyMember {
					name = firstName
				}
			}
		};
		
		enforce domain perDB personRegister : Persons::PersonRegister {
			persons = male : Persons::Male {
				name = fullName
			}
		};
		
		where {
			fullName = familyName + ', ' + firstName;
			firstName = firstName(fullName);
			familyName = familyName(fullName);
		}
	}

	relation Son2Male {
		familyName, firstName, fullName : String;
	
		checkonly domain famDB familyRegister : Families::FamilyRegister {
			families = family : Families::Family {
				name = familyName,
				sons = son : Families::FamilyMember {
					name = firstName
				}
			}
		};

		enforce domain perDB personRegister : Persons::PersonRegister {
			persons = male : Persons::Male {
				name = fullName
			}
		};
		
		where {
			fullName = familyName + ', ' + firstName;
			firstName = firstName(fullName);
			familyName = familyName(fullName);
		}
	}

	relation Mother2Female {
		familyName, firstName, fullName : String;
	
		enforce domain famDB familyRegister : Families::FamilyRegister {
			families = family : Families::Family {
				name = familyName,
				mother = mother : Families::FamilyMember {
					name = firstName
				}
			}
		};
		
		enforce domain perDB personRegister : Persons::PersonRegister {
			persons = female : Persons::Female {
				name = fullName
			}
		};
		
		where {
			fullName = familyName + ', ' + firstName;
			firstName = firstName(fullName);
			familyName = familyName(fullName);
		}
	}

	relation Daughter2Female {
		familyName, firstName, fullName : String;
	
		checkonly domain famDB familyRegister : Families::FamilyRegister {
			families = family : Families::Family {
				name = familyName,
				daughters = daughter : Families::FamilyMember {
					name = firstName
				}
			}
		};
		
		enforce domain perDB personRegister : Persons::PersonRegister {
			persons = female : Persons::Female {
				name = fullName
			}
		};
		
		where {
			fullName = familyName + ', ' + firstName;
			firstName = firstName(fullName);
			familyName = familyName(fullName);
		}
	}


}